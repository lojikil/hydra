#+TITLE: Digamma Todo lists
#+DATE: 15-DEC-2012
#+AUTHOR: Stefan Edwards <sae@lojikil.com>

* Runtime only

- DONE: Add support for #;(datum) comments
- DONE: port that to Hydra's runtime

* Vesta/Hydra
- engines
- current-input-port, current-output-port, current-error-port
- with-output, with-input, with-error
- get/set current-X-port

* Enyalios
- DONE: top level Symbol for procedures, added to lparams["env"]
- DONE: top level static snil, strue, &c.
- DONE: add static snil &c to top level Symbol
- DONE: add that top level Symbol to procedure calls
- closures in HOFs (HIGH 1)
- free analysis for closures (HIGH 1)
- Internally-defined procedure lifting (HIGH 1)
- Inlining
- typing ala Stalin (recursive union types, soft-typing/gradul-typing)
- named\-let (HIGH 2)
- do\-loops (I guess?)
- fix apply!
- DONE: (was actually an issue with set!) fix deeply nested let issue with if: (let ((foo 1)) (if (> foo 0) (set! foo 1) #v))
- letrec
- DONE: let* fix (doesn't correctly pass rewritten vars from above)
- fix load
- define-c-syntax
- define-syntax (HIGH 0)
- IL->JS, IL->C++, IL->JAVA, IL->X86_64, IL->SPARC
- support %c, define-alien for self-hosting runtimes.
- DONE: %include, %prim
- inline or lift
- if lift, do free analysis & closure conversion
- if an inner proc is used in _tail position_, inline it (maybe only if tail rec?)
- beter param shaddowing; no reliance on another var? no shaddowing
- optimize more primitives: + - / * < > >= <=
- open code fnumeq similar to eq?
- possibly look into destructive parameter updates? (foo (+ i 1)) could be AINT(i) += 1
- DONE: This fails to work correctly: (let ((i 0)) (set! i 10)) [test more; you can see it in Hydra/SAC. Could be only when it is nested in an if]
- DONE: check in on this: (foreach (fn (x) (write (keys x)) (newline)) some-var). Apparently generates the wrong environment in the output C code
- add merge-dict! procedure. It should default to _not_ overwriting keys that exist in the destination dictionary. (merge-dict! src : DICT dest : DICT overwrite? :BOOL)

* Hydra-only
- DONE: fix closures
- DONE: port closure fix to Hydra\/SAC
- DONE: review user of map, and potentially replace with bespoke, Enyalios\-friendly equivalent (SAC)
- idea: what if, instead of defining a list of primitives, &c., we just code primitives iff there is no other hit in the env? Users could do (define car (fn ...)), but it would not require having "car" defined in the env; a lookup against car could just hit a "default handler" of sorts. 
- DONE: Detect errors on the stack
- DONE: Detect errors on the stack in Hydra/SAC
- DONE: Move "display" instruction to be a call procedure instruction; top of stack is number of parameters.
- Fix `(define x '(primitive . 0)) (x '(1 2 3 4))` which returns `1`, aka it is able to run CAR (Sandbox escape 0)
- Fix `(define y '(procedure . "display")) (display 13)` which displays 13 & returns 13, aka is able to run procedures (Sandbox escape 1)
- For the above two sandbox escapes: maybe test with eq? which would ensure we're only running the values that were pre-allocated...
- For the above sandbox issues: wrap/tag user provided data with a USER tag; unwrap in all Hydra@vm at the right time (i.e. prior to call, but not for dispatch)
- The "eq?" version is better, I think, because it requires less memory overall; the tagged version requires each user value to be tagged, which is needlessly wasteful
- Core version without repl/read, for use with IL->JS
- Move stack from pair to vector with fixed size, stack pointer, &c. (testing)
- DONE: add define-syntax and syntax-expand to Hydra/SAC
- add define-syntax and syntax-expand to Hydra
- add define-macro and macro-expand to Hydra/SAC
- add define-macro and macro-expand to Hydra
- DONE: Move dump from pair to vector with fixed size, stack pointer, &c. (testing)
- DONE: hydra@{operand, instruction} => simple syntax
- DONE: add BEGIN form to Hydra
- DONE: add BEGIN form to Hydra/SAC
- Verify complete language coverage between Vesta and Hydra
- Errors buried deep within compiled code can bubble to the surface much later. Checkout Aneris.ss for a test (e.g. a call to "type" within an if block, when Hydra doesn't have the "type" procedure in its environment will call the error to be swallowed until much later. boo).
- Fix SegFault in Hydra/SAC with (append '() 3)

* Eurydice
- linting
- C-stress-style file system checks
- formatting (ala gofmt)
- refactoring: if<=>cond, cond<=>case, with<=>let, define<=>define-syntax, &c.

* All
- SRFI-0/7, for supporting different loads, different FFIs, different low-level runtimes...
- Scheme48-style modules.
- define-syntax
- SRFI-55 support (require) + Libraries
- better typing support
